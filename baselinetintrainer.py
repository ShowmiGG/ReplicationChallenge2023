# -*- coding: utf-8 -*-
"""AugMax.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WWwM1adedRNeoJ4-JjS0z0rrYv0o4yaC
"""

# Execute this code block to install dependencies when running on colab
# Execute this code block to install dependencies when running on colab
try:
    import torch
except:
    !pip install py
    !pip install torchvision
try: 
    import torchbearer
except:
    !pip install torchbearer

from google.colab import drive

drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd '/content/drive/MyDrive/repos/'

!wget http://cs231n.stanford.edu/tiny-imagenet-200.zip

!unzip  'tiny-imagenet-200.zip' -d 'tiny-imagenet-200-data1'

# Commented out IPython magic to ensure Python compatibility.
# %cd 'tiny-imagenet-200-data1'

import io
import glob
import os
from shutil import move
from os.path import join
from os import listdir, rmdir

target_folder = './tiny-imagenet-200/val/'
test_folder   = './tiny-imagenet-200/test/'

#os.mkdir(test_folder)
val_dict = {}
with open('./tiny-imagenet-200/val/val_annotations.txt', 'r') as f:
    for line in f.readlines():
        split_line = line.split('\t')
        val_dict[split_line[0]] = split_line[1]
        
paths = glob.glob('./tiny-imagenet-200/val/images/*')
for path in paths:
    file = path.split('/')[-1]
    folder = val_dict[file]
    if not os.path.exists(target_folder + str(folder)):
        os.mkdir(target_folder + str(folder))
        os.mkdir(target_folder + str(folder) + '/images')
    if not os.path.exists(test_folder + str(folder)):
        os.mkdir(test_folder + str(folder))
        os.mkdir(test_folder + str(folder) + '/images')
        
        
for path in paths:
    file = path.split('/')[-1]
    folder = val_dict[file]
    if len(glob.glob(target_folder + str(folder) + '/images/*')) <25:
        dest = target_folder + str(folder) + '/images/' + str(file)
    else:
        dest = test_folder + str(folder) + '/images/' + str(file)
    move(path, dest)

import torch, torchvision
import torch.nn as nn
import torch.optim as optim
from torch.optim import lr_scheduler
import torchvision.datasets as datasets
import torch.utils.data as data
import torchvision.transforms as transforms
from torch.autograd import Variable
import torchvision.models as models
from torchvision.datasets import ImageFolder
from torch.utils.data import DataLoader
from torchvision import transforms 
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import torch.nn.functional as F
from torch import nn
import torchbearer
from torchbearer import Trial
from torch import optim

model = models.resnet18(weights=None)

# Commented out IPython magic to ensure Python compatibility.
# %cd ..

model = torch.load('current.pth')

print(model)



batch_size=128

image_size=(224, 224)

transform = transforms.Compose([
            transforms.Resize(224),
            transforms.CenterCrop(224),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                 std=[0.229, 0.224, 0.225]),
        ])

train_dataset = ImageFolder("tiny-imagenet-200-data1/tiny-imagenet-200/train", transform)
train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)

val_dataset = ImageFolder("tiny-imagenet-200-data1/tiny-imagenet-200/val", transform)
val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)

test_dataset = ImageFolder("tiny-imagenet-200-data1/tiny-imagenet-200/test", transform)
test_loader = DataLoader(test_dataset, batch_size=batch_size, shuffle=False)

device = "cuda:0" if torch.cuda.is_available() else "cpu"

model.avgpool = nn.AdaptiveAvgPool2d((1,1))
model.fc = nn.Linear(512, len(train_dataset.classes))
model.train()

loss_function = nn.CrossEntropyLoss()
optimiser = optim.SGD(model.parameters(), lr=0.1)

for i in range(50):
  device = "cuda:0" if torch.cuda.is_available() else "cpu"
  trial = Trial(model, optimiser, loss_function, metrics=['loss', 'accuracy']).to(device)
  trial.with_generators(train_loader, val_generator=val_loader, test_generator=test_loader)
  trial.run(epochs=1)
  results = trial.evaluate(data_key=torchbearer.VALIDATION_DATA)

  torch.save(model,'current.pth')

torch.save(model,'current1.pth')